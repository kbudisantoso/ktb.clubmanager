// ktb.clubmanager Database Schema
// Documentation: docs/schema/

generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider = "postgresql"
}

/// A club or organization managed by the system (tenant).
/// Each club is completely isolated - members, accounts, and transactions
/// belong to exactly one club.
model Club {
  /// Unique identifier (CUID format)
  id          String  @id @default(cuid())
  /// Display name of the club (2-100 chars)
  name        String
  /// Legal/official name (up to 255 chars)
  legalName   String?
  /// URL-safe identifier (3-50 chars, unique)
  slug        String  @unique
  /// Optional description or notes about the club
  description String?

  /// Club visibility (PUBLIC = searchable, PRIVATE = invite-only)
  visibility ClubVisibility @default(PRIVATE)
  /// 8-char code for joining (XXXX-XXXX format stored without dash)
  inviteCode String?        @unique

  /// Avatar: either image URL or initials + color
  avatarUrl      String?
  /// 1-3 characters for avatar display
  avatarInitials String?
  /// Preset color name for avatar
  avatarColor    String?

  /// Tier for feature limits (optional)
  tierId String?
  tier   Tier?   @relation(fields: [tierId], references: [id])

  /// Soft deletion timestamp (null if not deleted)
  deletedAt DateTime?
  /// User ID who performed the soft deletion
  deletedBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clubUsers      ClubUser[]
  accessRequests AccessRequest[]
  members        Member[]
  ledgerAccounts LedgerAccount[]

  @@map("clubs")
}

/// Club visibility setting
enum ClubVisibility {
  /// Searchable in app, anyone can request access
  PUBLIC
  /// Hidden, requires invite code to find
  PRIVATE
}

// =============================================================================
// Multi-Tenancy Models
// =============================================================================
// ClubUser links users to clubs with roles.
// Tier defines feature limits for clubs.
// AccessRequest tracks join requests.

/// User's access to a club (junction table).
/// A user can belong to multiple clubs with different roles.
model ClubUser {
  id String @id @default(cuid())

  /// The user who has access
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// The club being accessed
  clubId String
  club   Club   @relation(fields: [clubId], references: [id], onDelete: Cascade)

  /// Roles within this club (1:n relationship, empty = no access)
  roles ClubRole[]

  /// Status of the user's access
  status ClubUserStatus @default(ACTIVE)

  /// When the user joined this club
  joinedAt DateTime @default(now())

  /// Who invited this user (optional)
  invitedById String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, clubId])
  @@index([clubId])
  @@index([userId])
  @@map("club_users")
}

/// Roles a user can have within a club (multiple roles per user possible)
enum ClubRole {
  /// Full control, all permissions
  OWNER
  /// Technical administration, user management (no finance access)
  ADMIN
  /// Financial features: bookkeeping, fees, SEPA, reports (no user management)
  TREASURER
  /// Protocols, documentation, board member
  SECRETARY
  /// Basic member access
  MEMBER
}

/// Status of a user's club membership
enum ClubUserStatus {
  /// Active access
  ACTIVE
  /// Invitation pending acceptance
  PENDING
  /// Access temporarily suspended
  SUSPENDED
}

/// Request for access to a club (for PUBLIC clubs or via invite code).
/// Requires admin approval.
model AccessRequest {
  id String @id @default(cuid())

  /// The user requesting access
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// The club being requested
  clubId String
  club   Club   @relation(fields: [clubId], references: [id], onDelete: Cascade)

  /// Optional message from the requester (max 500 chars)
  message String?

  /// Current status of the request
  status AccessRequestStatus @default(PENDING)

  /// Rejection handling
  rejectionReason AccessRejectionReason?
  /// Custom note for "OTHER" reason
  rejectionNote   String?
  /// Who processed this request
  processedById   String?
  /// When this request was processed
  processedAt     DateTime?
  /// When the user acknowledged seeing the rejection (null = not yet seen)
  seenAt          DateTime?

  /// Request expires after 30 days
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, clubId])
  @@index([clubId])
  @@index([userId])
  @@map("access_requests")
}

/// Status of an access request
enum AccessRequestStatus {
  /// Awaiting admin review
  PENDING
  /// Admin approved, user now has access
  APPROVED
  /// Admin rejected the request
  REJECTED
  /// Request expired without action
  EXPIRED
}

/// Reason for rejecting an access request
enum AccessRejectionReason {
  /// "Nur Vorstandsmitglieder haben Zugang"
  BOARD_ONLY
  /// "Wir konnten dich leider nicht zuordnen"
  UNIDENTIFIED
  /// "Das scheint nicht der richtige Verein zu sein"
  WRONG_CLUB
  /// "Bitte kontaktiere uns direkt"
  CONTACT_DIRECTLY
  /// Custom reason in rejectionNote
  OTHER
}

/// Tier/plan for clubs with feature flags and limits.
/// Supports future SaaS billing integration.
model Tier {
  id String @id @default(cuid())

  /// Display name of the tier
  name String @unique

  /// Description of what's included
  description String?

  /// Whether this tier is visible to users
  isVisible Boolean @default(true)

  /// Cannot be deleted if true (seeded tiers)
  isSeeded Boolean @default(false)

  /// Display order in tier selection
  sortOrder Int @default(0)

  /// Preset color name for display
  color String?

  /// Lucide icon name for display
  icon String?

  /// Limits (null = unlimited)
  /// Maximum users per club
  usersLimit   Int?
  /// Maximum members per club
  membersLimit Int?
  /// Storage limit in MB
  storageLimit Int?

  /// Feature flags
  /// SEPA direct debit enabled
  sepaEnabled       Boolean @default(true)
  /// Financial reports enabled
  reportsEnabled    Boolean @default(true)
  /// Bank statement import enabled
  bankImportEnabled Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Clubs on this tier
  clubs Club[]

  @@map("tiers")
}

// =============================================================================
// System Configuration
// =============================================================================

/// System-wide application settings (key-value store).
/// Used for configuration that doesn't belong to a specific club.
model AppSetting {
  /// Setting key (unique identifier)
  key String @id

  /// JSON-serialized value
  value String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("app_settings")
}

/// Audit log for tracking changes to entities.
/// Per ADR-0010: Row-Level Tenant Isolation.
model AuditLog {
  id String @id @default(cuid())

  /// Model name (e.g., "Club", "Member")
  entityType String

  /// ID of the affected entity
  entityId String

  /// Operation performed (create, update, delete)
  action String

  /// Who performed the action (null for system actions)
  userId String?

  /// Club context if applicable
  clubId String?

  /// What changed (before/after or input data)
  changes Json?

  /// Client IP address
  ipAddress String?

  /// Client user agent
  userAgent String?

  createdAt DateTime @default(now())

  @@index([entityType, entityId])
  @@index([userId])
  @@index([clubId])
  @@index([createdAt])
  @@map("audit_logs")
}

/// Status of a club member
enum MemberStatus {
  /// Currently active member with full privileges
  ACTIVE
  /// Temporarily inactive (e.g., sabbatical)
  INACTIVE
  /// Application pending approval
  PENDING
  /// Left the club (historical record)
  LEFT
}

/// A member of a club with contact information and membership details.
/// Members belong to exactly one club (tenant isolation).
model Member {
  /// Unique identifier (CUID format)
  id     String @id @default(cuid())
  /// Reference to the parent club (tenant)
  clubId String
  /// The club this member belongs to
  club   Club   @relation(fields: [clubId], references: [id])

  /// Member's full name
  name  String
  /// Email address (unique within club)
  email String?
  /// Phone number
  phone String?

  /// Street address
  street     String?
  /// Postal/ZIP code
  postalCode String?
  /// City
  city       String?

  /// Current membership status
  status   MemberStatus @default(ACTIVE)
  /// Date when member joined the club
  joinedAt DateTime?
  /// Date when member left (if status is LEFT)
  leftAt   DateTime?

  /// Soft deletion timestamp
  deletedAt DateTime?
  /// User ID who performed the soft deletion
  deletedBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clubId, email])
  @@index([clubId])
  @@map("members")
}

/// Type of account in the chart of accounts (SKR42)
enum AccountType {
  /// Assets (Aktivkonten) - Class 0-1
  ASSET
  /// Liabilities (Passivkonten) - Class 2-3
  LIABILITY
  /// Income (Ertragskonten) - Class 4
  INCOME
  /// Expense (Aufwandskonten) - Class 5-8
  EXPENSE
}

/// An account in the chart of accounts (Kontenrahmen).
/// Based on SKR42 for German non-profit organizations.
/// Named LedgerAccount to avoid conflict with Better Auth's Account model.
model LedgerAccount {
  /// Unique identifier (CUID format)
  id     String @id @default(cuid())
  /// Reference to the parent club (tenant)
  clubId String
  /// The club this account belongs to
  club   Club   @relation(fields: [clubId], references: [id])

  /// SKR42 account code (e.g., "1200" for Bank)
  code String
  /// Account name/description
  name String
  /// Type of account (asset, liability, income, expense)
  type AccountType

  /// Whether this account is active and can receive postings
  isActive Boolean @default(true)

  /// Soft deletion timestamp
  deletedAt DateTime?
  /// User ID who performed the soft deletion
  deletedBy String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([clubId, code])
  @@index([clubId])
  @@map("ledger_accounts")
}

// =============================================================================
// Authentication Models (Better Auth)
// =============================================================================
// These models support Better Auth with Prisma adapter.
// User externalId preserved for future Zitadel migration.
// Reference: https://www.better-auth.com/docs/adapters/prisma

/// Application user. Managed by Better Auth.
/// Soft-deletion supported per CONV-006.
model User {
  id String @id @default(cuid())

  /// External ID for future Zitadel migration (OIDC profile.sub claim)
  externalId String? @unique

  /// User's email address (from registration or OAuth)
  email String @unique

  /// Whether email has been verified
  emailVerified Boolean @default(false)

  /// Display name (from registration or OAuth profile)
  name String?

  /// Profile image URL (from OAuth provider or uploaded)
  image String?

  /// System-wide super admin flag (first user gets this automatically)
  isSuperAdmin Boolean @default(false)

  /// Terms & Conditions acceptance timestamp
  termsAcceptedAt DateTime?

  /// Soft-deletion fields (CONV-006)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?
  deletedBy String?

  /// Better Auth relations
  accounts Account[]
  sessions Session[]

  /// Multi-tenancy relations
  clubUsers      ClubUser[]
  accessRequests AccessRequest[]

  @@map("auth_users")
}

/// Auth account linked to a user (Better Auth adapter requirement)
/// Stores credentials and provider info for each auth method
model Account {
  id     String @id @default(cuid())
  userId String

  /// Provider identifier (e.g., "credential", "google", "github")
  providerId String

  /// Provider's account ID (user ID at provider, or internal ID for credentials)
  accountId String

  /// Password hash for credential provider (scrypt format)
  password String?

  /// OAuth tokens
  accessToken           String?   @db.Text
  refreshToken          String?   @db.Text
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?

  /// Token metadata
  scope   String?
  idToken String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerId, accountId])
  @@index([userId])
  @@map("auth_accounts")
}

/// User session (Better Auth adapter requirement)
/// Database-backed sessions for revocation support
model Session {
  id String @id @default(cuid())

  /// Session token for cookie validation
  token String @unique

  /// User who owns this session
  userId String

  /// When the session expires
  expiresAt DateTime

  /// Client metadata
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("auth_sessions")
}

/// Email verification token (Better Auth)
/// Used for email verification and password reset
model Verification {
  id String @id @default(cuid())

  /// What is being verified (email address, phone, etc.)
  identifier String

  /// The verification token/code
  value String

  /// When this verification expires
  expiresAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("auth_verifications")
}
